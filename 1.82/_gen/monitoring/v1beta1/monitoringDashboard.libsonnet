{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='monitoringDashboard', url='', help=''),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of MonitoringDashboard', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'monitoring.cnrm.cloud.google.com/v1beta1',
    kind: 'MonitoringDashboard',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help=''),
  spec: {
    '#columnLayout':: d.obj(help='"The content is divided into equally spaced columns and the widgets are arranged vertically."'),
    columnLayout: {
      '#columns':: d.obj(help='"The columns of content to display."'),
      columns: {
        '#widgets':: d.obj(help='"The display widgets arranged vertically in this column."'),
        widgets: {
          '#scorecard':: d.obj(help='"A scorecard summarizing time series data."'),
          scorecard: {
            '#gaugeView':: d.obj(help='"Will cause the scorecard to show a gauge chart."'),
            gaugeView: {
              '#withLowerBound':: d.fn(help='"The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this."', args=[d.arg(name='lowerBound', type=d.T.number)]),
              withLowerBound(lowerBound): { scorecard+: { gaugeView+: { lowerBound: lowerBound } } },
              '#withUpperBound':: d.fn(help='"The upper bound for this gauge chart. The value of the chart should always be less than or equal to this."', args=[d.arg(name='upperBound', type=d.T.number)]),
              withUpperBound(upperBound): { scorecard+: { gaugeView+: { upperBound: upperBound } } },
            },
            '#sparkChartView':: d.obj(help='"Will cause the scorecard to show a spark chart."'),
            sparkChartView: {
              '#withMinAlignmentPeriod':: d.fn(help='"The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { scorecard+: { sparkChartView+: { minAlignmentPeriod: minAlignmentPeriod } } },
              '#withSparkChartType':: d.fn(help='"Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR"', args=[d.arg(name='sparkChartType', type=d.T.string)]),
              withSparkChartType(sparkChartType): { scorecard+: { sparkChartView+: { sparkChartType: sparkChartType } } },
            },
            '#thresholds':: d.obj(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\""),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
            timeSeriesQuery: {
              '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
              timeSeriesFilter: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } } },
              },
              '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
              timeSeriesFilterRatio: {
                '#denominator':: d.obj(help='"The denominator of the ratio."'),
                denominator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } } },
                },
                '#numerator':: d.obj(help='"The numerator of the ratio."'),
                numerator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
              },
              '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
              withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { scorecard+: { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } } },
              '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
              withUnitOverride(unitOverride): { scorecard+: { timeSeriesQuery+: { unitOverride: unitOverride } } },
            },
            '#withThresholds':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { scorecard+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withThresholdsMixin':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { scorecard+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
          },
          '#text':: d.obj(help='"A raw string or markdown displaying textual content."'),
          text: {
            '#withContent':: d.fn(help='"The text content to be displayed."', args=[d.arg(name='content', type=d.T.string)]),
            withContent(content): { text+: { content: content } },
            '#withFormat':: d.fn(help='"How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW"', args=[d.arg(name='format', type=d.T.string)]),
            withFormat(format): { text+: { format: format } },
          },
          '#withBlank':: d.fn(help='"A blank space."', args=[d.arg(name='blank', type=d.T.object)]),
          withBlank(blank): { blank: blank },
          '#withBlankMixin':: d.fn(help='"A blank space."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blank', type=d.T.object)]),
          withBlankMixin(blank): { blank+: blank },
          '#withTitle':: d.fn(help='"Optional. The title of the widget."', args=[d.arg(name='title', type=d.T.string)]),
          withTitle(title): { title: title },
          '#xyChart':: d.obj(help='"A chart of time series data."'),
          xyChart: {
            '#chartOptions':: d.obj(help='"Display options for the chart."'),
            chartOptions: {
              '#withMode':: d.fn(help='"The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS"', args=[d.arg(name='mode', type=d.T.string)]),
              withMode(mode): { xyChart+: { chartOptions+: { mode: mode } } },
            },
            '#dataSets':: d.obj(help='"Required. The data displayed in this chart."'),
            dataSets: {
              '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
              timeSeriesQuery: {
                '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
                timeSeriesFilter: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } },
                },
                '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
                timeSeriesFilterRatio: {
                  '#denominator':: d.obj(help='"The denominator of the ratio."'),
                  denominator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } },
                  },
                  '#numerator':: d.obj(help='"The numerator of the ratio."'),
                  numerator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                },
                '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
                withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } },
                '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
                withUnitOverride(unitOverride): { timeSeriesQuery+: { unitOverride: unitOverride } },
              },
              '#withLegendTemplate':: d.fn(help="\"A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. \"", args=[d.arg(name='legendTemplate', type=d.T.string)]),
              withLegendTemplate(legendTemplate): { legendTemplate: legendTemplate },
              '#withMinAlignmentPeriod':: d.fn(help='"Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { minAlignmentPeriod: minAlignmentPeriod },
              '#withPlotType':: d.fn(help='"How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP"', args=[d.arg(name='plotType', type=d.T.string)]),
              withPlotType(plotType): { plotType: plotType },
            },
            '#thresholds':: d.obj(help='"Threshold lines drawn horizontally across the chart."'),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#withDataSets':: d.fn(help='"Required. The data displayed in this chart."', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSets(dataSets): { xyChart+: { dataSets: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
            '#withDataSetsMixin':: d.fn(help='"Required. The data displayed in this chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSetsMixin(dataSets): { xyChart+: { dataSets+: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
            '#withThresholds':: d.fn(help='"Threshold lines drawn horizontally across the chart."', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { xyChart+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withThresholdsMixin':: d.fn(help='"Threshold lines drawn horizontally across the chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { xyChart+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withTimeshiftDuration':: d.fn(help='"The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type."', args=[d.arg(name='timeshiftDuration', type=d.T.string)]),
            withTimeshiftDuration(timeshiftDuration): { xyChart+: { timeshiftDuration: timeshiftDuration } },
            '#xAxis':: d.obj(help='"The properties applied to the X axis."'),
            xAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { xyChart+: { xAxis+: { label: label } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { xyChart+: { xAxis+: { scale: scale } } },
            },
            '#yAxis':: d.obj(help='"The properties applied to the Y axis."'),
            yAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { xyChart+: { yAxis+: { label: label } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { xyChart+: { yAxis+: { scale: scale } } },
            },
          },
        },
        '#withWeight':: d.fn(help='"The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering."', args=[d.arg(name='weight', type=d.T.integer)]),
        withWeight(weight): { weight: weight },
        '#withWidgets':: d.fn(help='"The display widgets arranged vertically in this column."', args=[d.arg(name='widgets', type=d.T.array)]),
        withWidgets(widgets): { widgets: if std.isArray(v=widgets) then widgets else [widgets] },
        '#withWidgetsMixin':: d.fn(help='"The display widgets arranged vertically in this column."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='widgets', type=d.T.array)]),
        withWidgetsMixin(widgets): { widgets+: if std.isArray(v=widgets) then widgets else [widgets] },
      },
      '#withColumns':: d.fn(help='"The columns of content to display."', args=[d.arg(name='columns', type=d.T.array)]),
      withColumns(columns): { spec+: { columnLayout+: { columns: if std.isArray(v=columns) then columns else [columns] } } },
      '#withColumnsMixin':: d.fn(help='"The columns of content to display."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='columns', type=d.T.array)]),
      withColumnsMixin(columns): { spec+: { columnLayout+: { columns+: if std.isArray(v=columns) then columns else [columns] } } },
    },
    '#gridLayout':: d.obj(help='"Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles."'),
    gridLayout: {
      '#widgets':: d.obj(help='"The informational elements that are arranged into the columns row-first."'),
      widgets: {
        '#scorecard':: d.obj(help='"A scorecard summarizing time series data."'),
        scorecard: {
          '#gaugeView':: d.obj(help='"Will cause the scorecard to show a gauge chart."'),
          gaugeView: {
            '#withLowerBound':: d.fn(help='"The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this."', args=[d.arg(name='lowerBound', type=d.T.number)]),
            withLowerBound(lowerBound): { scorecard+: { gaugeView+: { lowerBound: lowerBound } } },
            '#withUpperBound':: d.fn(help='"The upper bound for this gauge chart. The value of the chart should always be less than or equal to this."', args=[d.arg(name='upperBound', type=d.T.number)]),
            withUpperBound(upperBound): { scorecard+: { gaugeView+: { upperBound: upperBound } } },
          },
          '#sparkChartView':: d.obj(help='"Will cause the scorecard to show a spark chart."'),
          sparkChartView: {
            '#withMinAlignmentPeriod':: d.fn(help='"The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
            withMinAlignmentPeriod(minAlignmentPeriod): { scorecard+: { sparkChartView+: { minAlignmentPeriod: minAlignmentPeriod } } },
            '#withSparkChartType':: d.fn(help='"Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR"', args=[d.arg(name='sparkChartType', type=d.T.string)]),
            withSparkChartType(sparkChartType): { scorecard+: { sparkChartView+: { sparkChartType: sparkChartType } } },
          },
          '#thresholds':: d.obj(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\""),
          thresholds: {
            '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
            withColor(color): { color: color },
            '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
            withDirection(direction): { direction: direction },
            '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
            withLabel(label): { label: label },
            '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
          timeSeriesQuery: {
            '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
            timeSeriesFilter: {
              '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
              aggregation: {
                '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
              },
              '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
              pickTimeSeriesFilter: {
                '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
              },
              '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
              secondaryAggregation: {
                '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
              },
              '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
              withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } } },
            },
            '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
            timeSeriesFilterRatio: {
              '#denominator':: d.obj(help='"The denominator of the ratio."'),
              denominator: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } } },
              },
              '#numerator':: d.obj(help='"The numerator of the ratio."'),
              numerator: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } } },
              },
              '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
              pickTimeSeriesFilter: {
                '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
              },
              '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
              secondaryAggregation: {
                '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
              },
            },
            '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
            withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { scorecard+: { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } } },
            '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
            withUnitOverride(unitOverride): { scorecard+: { timeSeriesQuery+: { unitOverride: unitOverride } } },
          },
          '#withThresholds':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"", args=[d.arg(name='thresholds', type=d.T.array)]),
          withThresholds(thresholds): { scorecard+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
          '#withThresholdsMixin':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='thresholds', type=d.T.array)]),
          withThresholdsMixin(thresholds): { scorecard+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
        },
        '#text':: d.obj(help='"A raw string or markdown displaying textual content."'),
        text: {
          '#withContent':: d.fn(help='"The text content to be displayed."', args=[d.arg(name='content', type=d.T.string)]),
          withContent(content): { text+: { content: content } },
          '#withFormat':: d.fn(help='"How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW"', args=[d.arg(name='format', type=d.T.string)]),
          withFormat(format): { text+: { format: format } },
        },
        '#withBlank':: d.fn(help='"A blank space."', args=[d.arg(name='blank', type=d.T.object)]),
        withBlank(blank): { blank: blank },
        '#withBlankMixin':: d.fn(help='"A blank space."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blank', type=d.T.object)]),
        withBlankMixin(blank): { blank+: blank },
        '#withTitle':: d.fn(help='"Optional. The title of the widget."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
        '#xyChart':: d.obj(help='"A chart of time series data."'),
        xyChart: {
          '#chartOptions':: d.obj(help='"Display options for the chart."'),
          chartOptions: {
            '#withMode':: d.fn(help='"The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS"', args=[d.arg(name='mode', type=d.T.string)]),
            withMode(mode): { xyChart+: { chartOptions+: { mode: mode } } },
          },
          '#dataSets':: d.obj(help='"Required. The data displayed in this chart."'),
          dataSets: {
            '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
            timeSeriesQuery: {
              '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
              timeSeriesFilter: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } },
              },
              '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
              timeSeriesFilterRatio: {
                '#denominator':: d.obj(help='"The denominator of the ratio."'),
                denominator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } },
                },
                '#numerator':: d.obj(help='"The numerator of the ratio."'),
                numerator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                },
              },
              '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
              withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } },
              '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
              withUnitOverride(unitOverride): { timeSeriesQuery+: { unitOverride: unitOverride } },
            },
            '#withLegendTemplate':: d.fn(help="\"A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. \"", args=[d.arg(name='legendTemplate', type=d.T.string)]),
            withLegendTemplate(legendTemplate): { legendTemplate: legendTemplate },
            '#withMinAlignmentPeriod':: d.fn(help='"Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
            withMinAlignmentPeriod(minAlignmentPeriod): { minAlignmentPeriod: minAlignmentPeriod },
            '#withPlotType':: d.fn(help='"How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP"', args=[d.arg(name='plotType', type=d.T.string)]),
            withPlotType(plotType): { plotType: plotType },
          },
          '#thresholds':: d.obj(help='"Threshold lines drawn horizontally across the chart."'),
          thresholds: {
            '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
            withColor(color): { color: color },
            '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
            withDirection(direction): { direction: direction },
            '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
            withLabel(label): { label: label },
            '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
            withValue(value): { value: value },
          },
          '#withDataSets':: d.fn(help='"Required. The data displayed in this chart."', args=[d.arg(name='dataSets', type=d.T.array)]),
          withDataSets(dataSets): { xyChart+: { dataSets: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
          '#withDataSetsMixin':: d.fn(help='"Required. The data displayed in this chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dataSets', type=d.T.array)]),
          withDataSetsMixin(dataSets): { xyChart+: { dataSets+: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
          '#withThresholds':: d.fn(help='"Threshold lines drawn horizontally across the chart."', args=[d.arg(name='thresholds', type=d.T.array)]),
          withThresholds(thresholds): { xyChart+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
          '#withThresholdsMixin':: d.fn(help='"Threshold lines drawn horizontally across the chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='thresholds', type=d.T.array)]),
          withThresholdsMixin(thresholds): { xyChart+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
          '#withTimeshiftDuration':: d.fn(help='"The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type."', args=[d.arg(name='timeshiftDuration', type=d.T.string)]),
          withTimeshiftDuration(timeshiftDuration): { xyChart+: { timeshiftDuration: timeshiftDuration } },
          '#xAxis':: d.obj(help='"The properties applied to the X axis."'),
          xAxis: {
            '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
            withLabel(label): { xyChart+: { xAxis+: { label: label } } },
            '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
            withScale(scale): { xyChart+: { xAxis+: { scale: scale } } },
          },
          '#yAxis':: d.obj(help='"The properties applied to the Y axis."'),
          yAxis: {
            '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
            withLabel(label): { xyChart+: { yAxis+: { label: label } } },
            '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
            withScale(scale): { xyChart+: { yAxis+: { scale: scale } } },
          },
        },
      },
      '#withColumns':: d.fn(help="\"The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.\"", args=[d.arg(name='columns', type=d.T.integer)]),
      withColumns(columns): { spec+: { gridLayout+: { columns: columns } } },
      '#withWidgets':: d.fn(help='"The informational elements that are arranged into the columns row-first."', args=[d.arg(name='widgets', type=d.T.array)]),
      withWidgets(widgets): { spec+: { gridLayout+: { widgets: if std.isArray(v=widgets) then widgets else [widgets] } } },
      '#withWidgetsMixin':: d.fn(help='"The informational elements that are arranged into the columns row-first."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='widgets', type=d.T.array)]),
      withWidgetsMixin(widgets): { spec+: { gridLayout+: { widgets+: if std.isArray(v=widgets) then widgets else [widgets] } } },
    },
    '#mosaicLayout':: d.obj(help='"The content is arranged as a grid of tiles, with each content widget occupying one or more tiles."'),
    mosaicLayout: {
      '#tiles':: d.obj(help='"The tiles to display."'),
      tiles: {
        '#widget':: d.obj(help='"The informational widget contained in the tile."'),
        widget: {
          '#scorecard':: d.obj(help='"A scorecard summarizing time series data."'),
          scorecard: {
            '#gaugeView':: d.obj(help='"Will cause the scorecard to show a gauge chart."'),
            gaugeView: {
              '#withLowerBound':: d.fn(help='"The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this."', args=[d.arg(name='lowerBound', type=d.T.number)]),
              withLowerBound(lowerBound): { widget+: { scorecard+: { gaugeView+: { lowerBound: lowerBound } } } },
              '#withUpperBound':: d.fn(help='"The upper bound for this gauge chart. The value of the chart should always be less than or equal to this."', args=[d.arg(name='upperBound', type=d.T.number)]),
              withUpperBound(upperBound): { widget+: { scorecard+: { gaugeView+: { upperBound: upperBound } } } },
            },
            '#sparkChartView':: d.obj(help='"Will cause the scorecard to show a spark chart."'),
            sparkChartView: {
              '#withMinAlignmentPeriod':: d.fn(help='"The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { widget+: { scorecard+: { sparkChartView+: { minAlignmentPeriod: minAlignmentPeriod } } } },
              '#withSparkChartType':: d.fn(help='"Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR"', args=[d.arg(name='sparkChartType', type=d.T.string)]),
              withSparkChartType(sparkChartType): { widget+: { scorecard+: { sparkChartView+: { sparkChartType: sparkChartType } } } },
            },
            '#thresholds':: d.obj(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\""),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
            timeSeriesQuery: {
              '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
              timeSeriesFilter: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } } } },
              },
              '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
              timeSeriesFilterRatio: {
                '#denominator':: d.obj(help='"The denominator of the ratio."'),
                denominator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } } } },
                },
                '#numerator':: d.obj(help='"The numerator of the ratio."'),
                numerator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                },
              },
              '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
              withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { widget+: { scorecard+: { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } } } },
              '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
              withUnitOverride(unitOverride): { widget+: { scorecard+: { timeSeriesQuery+: { unitOverride: unitOverride } } } },
            },
            '#withThresholds':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { widget+: { scorecard+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } } },
            '#withThresholdsMixin':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { widget+: { scorecard+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } } },
          },
          '#text':: d.obj(help='"A raw string or markdown displaying textual content."'),
          text: {
            '#withContent':: d.fn(help='"The text content to be displayed."', args=[d.arg(name='content', type=d.T.string)]),
            withContent(content): { widget+: { text+: { content: content } } },
            '#withFormat':: d.fn(help='"How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW"', args=[d.arg(name='format', type=d.T.string)]),
            withFormat(format): { widget+: { text+: { format: format } } },
          },
          '#withBlank':: d.fn(help='"A blank space."', args=[d.arg(name='blank', type=d.T.object)]),
          withBlank(blank): { widget+: { blank: blank } },
          '#withBlankMixin':: d.fn(help='"A blank space."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blank', type=d.T.object)]),
          withBlankMixin(blank): { widget+: { blank+: blank } },
          '#withTitle':: d.fn(help='"Optional. The title of the widget."', args=[d.arg(name='title', type=d.T.string)]),
          withTitle(title): { widget+: { title: title } },
          '#xyChart':: d.obj(help='"A chart of time series data."'),
          xyChart: {
            '#chartOptions':: d.obj(help='"Display options for the chart."'),
            chartOptions: {
              '#withMode':: d.fn(help='"The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS"', args=[d.arg(name='mode', type=d.T.string)]),
              withMode(mode): { widget+: { xyChart+: { chartOptions+: { mode: mode } } } },
            },
            '#dataSets':: d.obj(help='"Required. The data displayed in this chart."'),
            dataSets: {
              '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
              timeSeriesQuery: {
                '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
                timeSeriesFilter: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } },
                },
                '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
                timeSeriesFilterRatio: {
                  '#denominator':: d.obj(help='"The denominator of the ratio."'),
                  denominator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } },
                  },
                  '#numerator':: d.obj(help='"The numerator of the ratio."'),
                  numerator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                },
                '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
                withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } },
                '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
                withUnitOverride(unitOverride): { timeSeriesQuery+: { unitOverride: unitOverride } },
              },
              '#withLegendTemplate':: d.fn(help="\"A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. \"", args=[d.arg(name='legendTemplate', type=d.T.string)]),
              withLegendTemplate(legendTemplate): { legendTemplate: legendTemplate },
              '#withMinAlignmentPeriod':: d.fn(help='"Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { minAlignmentPeriod: minAlignmentPeriod },
              '#withPlotType':: d.fn(help='"How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP"', args=[d.arg(name='plotType', type=d.T.string)]),
              withPlotType(plotType): { plotType: plotType },
            },
            '#thresholds':: d.obj(help='"Threshold lines drawn horizontally across the chart."'),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#withDataSets':: d.fn(help='"Required. The data displayed in this chart."', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSets(dataSets): { widget+: { xyChart+: { dataSets: if std.isArray(v=dataSets) then dataSets else [dataSets] } } },
            '#withDataSetsMixin':: d.fn(help='"Required. The data displayed in this chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSetsMixin(dataSets): { widget+: { xyChart+: { dataSets+: if std.isArray(v=dataSets) then dataSets else [dataSets] } } },
            '#withThresholds':: d.fn(help='"Threshold lines drawn horizontally across the chart."', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { widget+: { xyChart+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } } },
            '#withThresholdsMixin':: d.fn(help='"Threshold lines drawn horizontally across the chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { widget+: { xyChart+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } } },
            '#withTimeshiftDuration':: d.fn(help='"The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type."', args=[d.arg(name='timeshiftDuration', type=d.T.string)]),
            withTimeshiftDuration(timeshiftDuration): { widget+: { xyChart+: { timeshiftDuration: timeshiftDuration } } },
            '#xAxis':: d.obj(help='"The properties applied to the X axis."'),
            xAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { widget+: { xyChart+: { xAxis+: { label: label } } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { widget+: { xyChart+: { xAxis+: { scale: scale } } } },
            },
            '#yAxis':: d.obj(help='"The properties applied to the Y axis."'),
            yAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { widget+: { xyChart+: { yAxis+: { label: label } } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { widget+: { xyChart+: { yAxis+: { scale: scale } } } },
            },
          },
        },
        '#withHeight':: d.fn(help='"The height of the tile, measured in grid squares."', args=[d.arg(name='height', type=d.T.integer)]),
        withHeight(height): { height: height },
        '#withWidth':: d.fn(help='"The width of the tile, measured in grid squares."', args=[d.arg(name='width', type=d.T.integer)]),
        withWidth(width): { width: width },
        '#withXPos':: d.fn(help='"The zero-indexed position of the tile in grid squares relative to the left edge of the grid."', args=[d.arg(name='xPos', type=d.T.integer)]),
        withXPos(xPos): { xPos: xPos },
        '#withYPos':: d.fn(help='"The zero-indexed position of the tile in grid squares relative to the top edge of the grid."', args=[d.arg(name='yPos', type=d.T.integer)]),
        withYPos(yPos): { yPos: yPos },
      },
      '#withColumns':: d.fn(help='"The number of columns in the mosaic grid."', args=[d.arg(name='columns', type=d.T.integer)]),
      withColumns(columns): { spec+: { mosaicLayout+: { columns: columns } } },
      '#withTiles':: d.fn(help='"The tiles to display."', args=[d.arg(name='tiles', type=d.T.array)]),
      withTiles(tiles): { spec+: { mosaicLayout+: { tiles: if std.isArray(v=tiles) then tiles else [tiles] } } },
      '#withTilesMixin':: d.fn(help='"The tiles to display."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tiles', type=d.T.array)]),
      withTilesMixin(tiles): { spec+: { mosaicLayout+: { tiles+: if std.isArray(v=tiles) then tiles else [tiles] } } },
    },
    '#projectRef':: d.obj(help='"The Project that this resource belongs to."'),
    projectRef: {
      '#withExternal':: d.fn(help='"The project id of the resource.\\n\\nAllowed value: The Google Cloud resource name of a `Project` resource (format: `projects/{{name}}`)."', args=[d.arg(name='external', type=d.T.string)]),
      withExternal(external): { spec+: { projectRef+: { external: external } } },
      '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { spec+: { projectRef+: { name: name } } },
      '#withNamespace':: d.fn(help='"Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/"', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { projectRef+: { namespace: namespace } } },
    },
    '#rowLayout':: d.obj(help='"The content is divided into equally spaced rows and the widgets are arranged horizontally."'),
    rowLayout: {
      '#rows':: d.obj(help='"The rows of content to display."'),
      rows: {
        '#widgets':: d.obj(help='"The display widgets arranged horizontally in this row."'),
        widgets: {
          '#scorecard':: d.obj(help='"A scorecard summarizing time series data."'),
          scorecard: {
            '#gaugeView':: d.obj(help='"Will cause the scorecard to show a gauge chart."'),
            gaugeView: {
              '#withLowerBound':: d.fn(help='"The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this."', args=[d.arg(name='lowerBound', type=d.T.number)]),
              withLowerBound(lowerBound): { scorecard+: { gaugeView+: { lowerBound: lowerBound } } },
              '#withUpperBound':: d.fn(help='"The upper bound for this gauge chart. The value of the chart should always be less than or equal to this."', args=[d.arg(name='upperBound', type=d.T.number)]),
              withUpperBound(upperBound): { scorecard+: { gaugeView+: { upperBound: upperBound } } },
            },
            '#sparkChartView':: d.obj(help='"Will cause the scorecard to show a spark chart."'),
            sparkChartView: {
              '#withMinAlignmentPeriod':: d.fn(help='"The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { scorecard+: { sparkChartView+: { minAlignmentPeriod: minAlignmentPeriod } } },
              '#withSparkChartType':: d.fn(help='"Required. The type of sparkchart to show in this chartView. Possible values: SPARK_CHART_TYPE_UNSPECIFIED, SPARK_LINE, SPARK_BAR"', args=[d.arg(name='sparkChartType', type=d.T.string)]),
              withSparkChartType(sparkChartType): { scorecard+: { sparkChartView+: { sparkChartType: sparkChartType } } },
            },
            '#thresholds':: d.obj(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\""),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
            timeSeriesQuery: {
              '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
              timeSeriesFilter: {
                '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                aggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
                '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } } },
              },
              '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
              timeSeriesFilterRatio: {
                '#denominator':: d.obj(help='"The denominator of the ratio."'),
                denominator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } } },
                },
                '#numerator':: d.obj(help='"The numerator of the ratio."'),
                numerator: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } } },
                },
                '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                pickTimeSeriesFilter: {
                  '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                  withDirection(direction): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } } },
                  '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                  withNumTimeSeries(numTimeSeries): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } } },
                  '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                  withRankingMethod(rankingMethod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } } },
                },
                '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                secondaryAggregation: {
                  '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                  withAlignmentPeriod(alignmentPeriod): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                  '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                  withCrossSeriesReducer(crossSeriesReducer): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                  '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFields(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                  withGroupByFieldsMixin(groupByFields): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                  '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                  withPerSeriesAligner(perSeriesAligner): { scorecard+: { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                },
              },
              '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
              withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { scorecard+: { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } } },
              '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
              withUnitOverride(unitOverride): { scorecard+: { timeSeriesQuery+: { unitOverride: unitOverride } } },
            },
            '#withThresholds':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { scorecard+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withThresholdsMixin':: d.fn(help="\"The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)  As an example, consider a scorecard with the following four thresholds: {   value: 90,   category: 'DANGER',   trigger: 'ABOVE', },: {   value: 70,   category: 'WARNING',   trigger: 'ABOVE', }, {   value: 10,   category: 'DANGER',   trigger: 'BELOW', }, {   value: 20,   category: 'WARNING',   trigger: 'BELOW', }  Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { scorecard+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
          },
          '#text':: d.obj(help='"A raw string or markdown displaying textual content."'),
          text: {
            '#withContent':: d.fn(help='"The text content to be displayed."', args=[d.arg(name='content', type=d.T.string)]),
            withContent(content): { text+: { content: content } },
            '#withFormat':: d.fn(help='"How the text content is formatted. Possible values: FORMAT_UNSPECIFIED, MARKDOWN, RAW"', args=[d.arg(name='format', type=d.T.string)]),
            withFormat(format): { text+: { format: format } },
          },
          '#withBlank':: d.fn(help='"A blank space."', args=[d.arg(name='blank', type=d.T.object)]),
          withBlank(blank): { blank: blank },
          '#withBlankMixin':: d.fn(help='"A blank space."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='blank', type=d.T.object)]),
          withBlankMixin(blank): { blank+: blank },
          '#withTitle':: d.fn(help='"Optional. The title of the widget."', args=[d.arg(name='title', type=d.T.string)]),
          withTitle(title): { title: title },
          '#xyChart':: d.obj(help='"A chart of time series data."'),
          xyChart: {
            '#chartOptions':: d.obj(help='"Display options for the chart."'),
            chartOptions: {
              '#withMode':: d.fn(help='"The chart mode. Possible values: MODE_UNSPECIFIED, COLOR, X_RAY, STATS"', args=[d.arg(name='mode', type=d.T.string)]),
              withMode(mode): { xyChart+: { chartOptions+: { mode: mode } } },
            },
            '#dataSets':: d.obj(help='"Required. The data displayed in this chart."'),
            dataSets: {
              '#timeSeriesQuery':: d.obj(help='"Required. Fields for querying time series data from the Stackdriver metrics API."'),
              timeSeriesQuery: {
                '#timeSeriesFilter':: d.obj(help='"Filter parameters to fetch time series."'),
                timeSeriesFilter: {
                  '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                  aggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilter+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after `aggregation` is applied."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilter+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                  '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                  withFilter(filter): { timeSeriesQuery+: { timeSeriesFilter+: { filter: filter } } },
                },
                '#timeSeriesFilterRatio':: d.obj(help='"Parameters to fetch a ratio between two time series filters."'),
                timeSeriesFilterRatio: {
                  '#denominator':: d.obj(help='"The denominator of the ratio."'),
                  denominator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { denominator+: { filter: filter } } } },
                  },
                  '#numerator':: d.obj(help='"The numerator of the ratio."'),
                  numerator: {
                    '#aggregation':: d.obj(help='"By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."'),
                    aggregation: {
                      '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                      withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { alignmentPeriod: alignmentPeriod } } } } },
                      '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                      withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { crossSeriesReducer: crossSeriesReducer } } } } },
                      '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                      withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } } },
                      '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                      withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { aggregation+: { perSeriesAligner: perSeriesAligner } } } } },
                    },
                    '#withFilter':: d.fn(help='"Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query."', args=[d.arg(name='filter', type=d.T.string)]),
                    withFilter(filter): { timeSeriesQuery+: { timeSeriesFilterRatio+: { numerator+: { filter: filter } } } },
                  },
                  '#pickTimeSeriesFilter':: d.obj(help='"Ranking based time series filter."'),
                  pickTimeSeriesFilter: {
                    '#withDirection':: d.fn(help='"How to use the ranking to select time series that pass through the filter. Possible values: DIRECTION_UNSPECIFIED, TOP, BOTTOM"', args=[d.arg(name='direction', type=d.T.string)]),
                    withDirection(direction): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { direction: direction } } } },
                    '#withNumTimeSeries':: d.fn(help='"How many time series to allow to pass through the filter."', args=[d.arg(name='numTimeSeries', type=d.T.integer)]),
                    withNumTimeSeries(numTimeSeries): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { numTimeSeries: numTimeSeries } } } },
                    '#withRankingMethod':: d.fn(help='"`ranking_method` is applied to each time series independently to produce the value which will be used to compare the time series to other time series. Possible values: METHOD_UNSPECIFIED, METHOD_MEAN, METHOD_MAX, METHOD_MIN, METHOD_SUM, METHOD_LATEST"', args=[d.arg(name='rankingMethod', type=d.T.string)]),
                    withRankingMethod(rankingMethod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { pickTimeSeriesFilter+: { rankingMethod: rankingMethod } } } },
                  },
                  '#secondaryAggregation':: d.obj(help='"Apply a second aggregation after the ratio is computed."'),
                  secondaryAggregation: {
                    '#withAlignmentPeriod':: d.fn(help='"The `alignment_period` specifies a time interval, in seconds, that is used to divide the data in all the [time series][google.monitoring.v3.TimeSeries] into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.  The value must be at least 60 seconds. If a per-series aligner other than `ALIGN_NONE` is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner `ALIGN_NONE` is specified, then this field is ignored."', args=[d.arg(name='alignmentPeriod', type=d.T.string)]),
                    withAlignmentPeriod(alignmentPeriod): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { alignmentPeriod: alignmentPeriod } } } },
                    '#withCrossSeriesReducer':: d.fn(help='"The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.  Not all reducer operations can be applied to all time series. The valid choices depend on the `metric_kind` and the `value_type` of the original time series. Reduction can yield a time series with a different `metric_kind` or `value_type` than the input time series.  Time series data must first be aligned (see `per_series_aligner`) in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified, and must not be `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an error is returned. Possible values: REDUCE_NONE, REDUCE_MEAN, REDUCE_MIN, REDUCE_MAX, REDUCE_SUM, REDUCE_STDDEV, REDUCE_COUNT, REDUCE_COUNT_TRUE, REDUCE_COUNT_FALSE, REDUCE_FRACTION_TRUE, REDUCE_PERCENTILE_99, REDUCE_PERCENTILE_95, REDUCE_PERCENTILE_50, REDUCE_PERCENTILE_05, REDUCE_FRACTION_LESS_THAN, REDUCE_MAKE_DISTRIBUTION"', args=[d.arg(name='crossSeriesReducer', type=d.T.string)]),
                    withCrossSeriesReducer(crossSeriesReducer): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { crossSeriesReducer: crossSeriesReducer } } } },
                    '#withGroupByFields':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFields(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withGroupByFieldsMixin':: d.fn(help='"The set of fields to preserve when `cross_series_reducer` is specified. The `group_by_fields` determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The `cross_series_reducer` is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains `resource.type`.  Fields not specified in `group_by_fields` are aggregated away.  If `group_by_fields` is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If `cross_series_reducer` is not defined, this field is ignored."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupByFields', type=d.T.array)]),
                    withGroupByFieldsMixin(groupByFields): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { groupByFields+: if std.isArray(v=groupByFields) then groupByFields else [groupByFields] } } } },
                    '#withPerSeriesAligner':: d.fn(help='"An `Aligner` describes how to bring the data points in a single time series into temporal alignment. Except for `ALIGN_NONE`, all alignments cause all the data points in an `alignment_period` to be mathematically grouped together, resulting in a single data point for each `alignment_period` with end timestamp at the end of the period.  Not all alignment operations may be applied to all time series. The valid choices depend on the `metric_kind` and `value_type` of the original time series. Alignment can change the `metric_kind` or the `value_type` of the time series.  Time series data must be aligned in order to perform cross-time series reduction. If `cross_series_reducer` is specified, then `per_series_aligner` must be specified and not equal to `ALIGN_NONE` and `alignment_period` must be specified; otherwise, an error is returned."', args=[d.arg(name='perSeriesAligner', type=d.T.string)]),
                    withPerSeriesAligner(perSeriesAligner): { timeSeriesQuery+: { timeSeriesFilterRatio+: { secondaryAggregation+: { perSeriesAligner: perSeriesAligner } } } },
                  },
                },
                '#withTimeSeriesQueryLanguage':: d.fn(help='"A query used to fetch time series."', args=[d.arg(name='timeSeriesQueryLanguage', type=d.T.string)]),
                withTimeSeriesQueryLanguage(timeSeriesQueryLanguage): { timeSeriesQuery+: { timeSeriesQueryLanguage: timeSeriesQueryLanguage } },
                '#withUnitOverride':: d.fn(help='"The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in `MetricDescriptor`."', args=[d.arg(name='unitOverride', type=d.T.string)]),
                withUnitOverride(unitOverride): { timeSeriesQuery+: { unitOverride: unitOverride } },
              },
              '#withLegendTemplate':: d.fn(help="\"A template string for naming `TimeSeries` in the resulting data set. This should be a string with interpolations of the form `${label_name}`, which will resolve to the label's value. \"", args=[d.arg(name='legendTemplate', type=d.T.string)]),
              withLegendTemplate(legendTemplate): { legendTemplate: legendTemplate },
              '#withMinAlignmentPeriod':: d.fn(help='"Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the `min_alignment_period` should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals."', args=[d.arg(name='minAlignmentPeriod', type=d.T.string)]),
              withMinAlignmentPeriod(minAlignmentPeriod): { minAlignmentPeriod: minAlignmentPeriod },
              '#withPlotType':: d.fn(help='"How this data should be plotted on the chart. Possible values: PLOT_TYPE_UNSPECIFIED, LINE, STACKED_AREA, STACKED_BAR, HEATMAP"', args=[d.arg(name='plotType', type=d.T.string)]),
              withPlotType(plotType): { plotType: plotType },
            },
            '#thresholds':: d.obj(help='"Threshold lines drawn horizontally across the chart."'),
            thresholds: {
              '#withColor':: d.fn(help='"The state color for this threshold. Color is not allowed in a XyChart. Possible values: COLOR_UNSPECIFIED, GREY, BLUE, GREEN, YELLOW, ORANGE, RED"', args=[d.arg(name='color', type=d.T.string)]),
              withColor(color): { color: color },
              '#withDirection':: d.fn(help='"The direction for the current threshold. Direction is not allowed in a XyChart. Possible values: DIRECTION_UNSPECIFIED, ABOVE, BELOW"', args=[d.arg(name='direction', type=d.T.string)]),
              withDirection(direction): { direction: direction },
              '#withLabel':: d.fn(help='"A label for the threshold."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { label: label },
              '#withValue':: d.fn(help='"The value of the threshold. The value should be defined in the native scale of the metric."', args=[d.arg(name='value', type=d.T.number)]),
              withValue(value): { value: value },
            },
            '#withDataSets':: d.fn(help='"Required. The data displayed in this chart."', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSets(dataSets): { xyChart+: { dataSets: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
            '#withDataSetsMixin':: d.fn(help='"Required. The data displayed in this chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dataSets', type=d.T.array)]),
            withDataSetsMixin(dataSets): { xyChart+: { dataSets+: if std.isArray(v=dataSets) then dataSets else [dataSets] } },
            '#withThresholds':: d.fn(help='"Threshold lines drawn horizontally across the chart."', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholds(thresholds): { xyChart+: { thresholds: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withThresholdsMixin':: d.fn(help='"Threshold lines drawn horizontally across the chart."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='thresholds', type=d.T.array)]),
            withThresholdsMixin(thresholds): { xyChart+: { thresholds+: if std.isArray(v=thresholds) then thresholds else [thresholds] } },
            '#withTimeshiftDuration':: d.fn(help='"The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type."', args=[d.arg(name='timeshiftDuration', type=d.T.string)]),
            withTimeshiftDuration(timeshiftDuration): { xyChart+: { timeshiftDuration: timeshiftDuration } },
            '#xAxis':: d.obj(help='"The properties applied to the X axis."'),
            xAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { xyChart+: { xAxis+: { label: label } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { xyChart+: { xAxis+: { scale: scale } } },
            },
            '#yAxis':: d.obj(help='"The properties applied to the Y axis."'),
            yAxis: {
              '#withLabel':: d.fn(help='"The label of the axis."', args=[d.arg(name='label', type=d.T.string)]),
              withLabel(label): { xyChart+: { yAxis+: { label: label } } },
              '#withScale':: d.fn(help='"The axis scale. By default, a linear scale is used. Possible values: SCALE_UNSPECIFIED, LINEAR, LOG10"', args=[d.arg(name='scale', type=d.T.string)]),
              withScale(scale): { xyChart+: { yAxis+: { scale: scale } } },
            },
          },
        },
        '#withWeight':: d.fn(help='"The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering."', args=[d.arg(name='weight', type=d.T.integer)]),
        withWeight(weight): { weight: weight },
        '#withWidgets':: d.fn(help='"The display widgets arranged horizontally in this row."', args=[d.arg(name='widgets', type=d.T.array)]),
        withWidgets(widgets): { widgets: if std.isArray(v=widgets) then widgets else [widgets] },
        '#withWidgetsMixin':: d.fn(help='"The display widgets arranged horizontally in this row."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='widgets', type=d.T.array)]),
        withWidgetsMixin(widgets): { widgets+: if std.isArray(v=widgets) then widgets else [widgets] },
      },
      '#withRows':: d.fn(help='"The rows of content to display."', args=[d.arg(name='rows', type=d.T.array)]),
      withRows(rows): { spec+: { rowLayout+: { rows: if std.isArray(v=rows) then rows else [rows] } } },
      '#withRowsMixin':: d.fn(help='"The rows of content to display."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rows', type=d.T.array)]),
      withRowsMixin(rows): { spec+: { rowLayout+: { rows+: if std.isArray(v=rows) then rows else [rows] } } },
    },
    '#withDisplayName':: d.fn(help='"Required. The mutable, human-readable name."', args=[d.arg(name='displayName', type=d.T.string)]),
    withDisplayName(displayName): { spec+: { displayName: displayName } },
    '#withResourceID':: d.fn(help='"Immutable. Optional. The name of the resource. Used for creation and acquisition. When unset, the value of `metadata.name` is used as the default."', args=[d.arg(name='resourceID', type=d.T.string)]),
    withResourceID(resourceID): { spec+: { resourceID: resourceID } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
